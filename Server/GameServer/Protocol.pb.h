// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class CTS_CHAT;
struct CTS_CHATDefaultTypeInternal;
extern CTS_CHATDefaultTypeInternal _CTS_CHAT_default_instance_;
class CTS_ENTER_GAME;
struct CTS_ENTER_GAMEDefaultTypeInternal;
extern CTS_ENTER_GAMEDefaultTypeInternal _CTS_ENTER_GAME_default_instance_;
class CTS_LEAVE_GAME;
struct CTS_LEAVE_GAMEDefaultTypeInternal;
extern CTS_LEAVE_GAMEDefaultTypeInternal _CTS_LEAVE_GAME_default_instance_;
class CTS_LOGIN;
struct CTS_LOGINDefaultTypeInternal;
extern CTS_LOGINDefaultTypeInternal _CTS_LOGIN_default_instance_;
class CTS_MOVE;
struct CTS_MOVEDefaultTypeInternal;
extern CTS_MOVEDefaultTypeInternal _CTS_MOVE_default_instance_;
class STC_CHAT;
struct STC_CHATDefaultTypeInternal;
extern STC_CHATDefaultTypeInternal _STC_CHAT_default_instance_;
class STC_DESPAWN;
struct STC_DESPAWNDefaultTypeInternal;
extern STC_DESPAWNDefaultTypeInternal _STC_DESPAWN_default_instance_;
class STC_ENTER_GAME;
struct STC_ENTER_GAMEDefaultTypeInternal;
extern STC_ENTER_GAMEDefaultTypeInternal _STC_ENTER_GAME_default_instance_;
class STC_LEAVE_GAME;
struct STC_LEAVE_GAMEDefaultTypeInternal;
extern STC_LEAVE_GAMEDefaultTypeInternal _STC_LEAVE_GAME_default_instance_;
class STC_LOGIN;
struct STC_LOGINDefaultTypeInternal;
extern STC_LOGINDefaultTypeInternal _STC_LOGIN_default_instance_;
class STC_MOVE;
struct STC_MOVEDefaultTypeInternal;
extern STC_MOVEDefaultTypeInternal _STC_MOVE_default_instance_;
class STC_SPAWN;
struct STC_SPAWNDefaultTypeInternal;
extern STC_SPAWNDefaultTypeInternal _STC_SPAWN_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::CTS_CHAT* Arena::CreateMaybeMessage<::Protocol::CTS_CHAT>(Arena*);
template<> ::Protocol::CTS_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::CTS_ENTER_GAME>(Arena*);
template<> ::Protocol::CTS_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::CTS_LEAVE_GAME>(Arena*);
template<> ::Protocol::CTS_LOGIN* Arena::CreateMaybeMessage<::Protocol::CTS_LOGIN>(Arena*);
template<> ::Protocol::CTS_MOVE* Arena::CreateMaybeMessage<::Protocol::CTS_MOVE>(Arena*);
template<> ::Protocol::STC_CHAT* Arena::CreateMaybeMessage<::Protocol::STC_CHAT>(Arena*);
template<> ::Protocol::STC_DESPAWN* Arena::CreateMaybeMessage<::Protocol::STC_DESPAWN>(Arena*);
template<> ::Protocol::STC_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::STC_ENTER_GAME>(Arena*);
template<> ::Protocol::STC_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::STC_LEAVE_GAME>(Arena*);
template<> ::Protocol::STC_LOGIN* Arena::CreateMaybeMessage<::Protocol::STC_LOGIN>(Arena*);
template<> ::Protocol::STC_MOVE* Arena::CreateMaybeMessage<::Protocol::STC_MOVE>(Arena*);
template<> ::Protocol::STC_SPAWN* Arena::CreateMaybeMessage<::Protocol::STC_SPAWN>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class CTS_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CTS_LOGIN) */ {
 public:
  inline CTS_LOGIN() : CTS_LOGIN(nullptr) {}
  ~CTS_LOGIN() override;
  explicit constexpr CTS_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTS_LOGIN(const CTS_LOGIN& from);
  CTS_LOGIN(CTS_LOGIN&& from) noexcept
    : CTS_LOGIN() {
    *this = ::std::move(from);
  }

  inline CTS_LOGIN& operator=(const CTS_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTS_LOGIN& operator=(CTS_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTS_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTS_LOGIN* internal_default_instance() {
    return reinterpret_cast<const CTS_LOGIN*>(
               &_CTS_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CTS_LOGIN& a, CTS_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(CTS_LOGIN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTS_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CTS_LOGIN* New() const final {
    return new CTS_LOGIN();
  }

  CTS_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CTS_LOGIN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CTS_LOGIN& from);
  void MergeFrom(const CTS_LOGIN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTS_LOGIN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CTS_LOGIN";
  }
  protected:
  explicit CTS_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.CTS_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_LOGIN) */ {
 public:
  inline STC_LOGIN() : STC_LOGIN(nullptr) {}
  ~STC_LOGIN() override;
  explicit constexpr STC_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_LOGIN(const STC_LOGIN& from);
  STC_LOGIN(STC_LOGIN&& from) noexcept
    : STC_LOGIN() {
    *this = ::std::move(from);
  }

  inline STC_LOGIN& operator=(const STC_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_LOGIN& operator=(STC_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_LOGIN* internal_default_instance() {
    return reinterpret_cast<const STC_LOGIN*>(
               &_STC_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(STC_LOGIN& a, STC_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_LOGIN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_LOGIN* New() const final {
    return new STC_LOGIN();
  }

  STC_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_LOGIN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_LOGIN& from);
  void MergeFrom(const STC_LOGIN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_LOGIN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_LOGIN";
  }
  protected:
  explicit STC_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.STC_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CTS_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CTS_ENTER_GAME) */ {
 public:
  inline CTS_ENTER_GAME() : CTS_ENTER_GAME(nullptr) {}
  ~CTS_ENTER_GAME() override;
  explicit constexpr CTS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTS_ENTER_GAME(const CTS_ENTER_GAME& from);
  CTS_ENTER_GAME(CTS_ENTER_GAME&& from) noexcept
    : CTS_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline CTS_ENTER_GAME& operator=(const CTS_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTS_ENTER_GAME& operator=(CTS_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTS_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTS_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const CTS_ENTER_GAME*>(
               &_CTS_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CTS_ENTER_GAME& a, CTS_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(CTS_ENTER_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTS_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CTS_ENTER_GAME* New() const final {
    return new CTS_ENTER_GAME();
  }

  CTS_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CTS_ENTER_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CTS_ENTER_GAME& from);
  void MergeFrom(const CTS_ENTER_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTS_ENTER_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CTS_ENTER_GAME";
  }
  protected:
  explicit CTS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
  };
  // uint64 playerIndex = 1;
  void clear_playerindex();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerindex() const;
  void set_playerindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerindex() const;
  void _internal_set_playerindex(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CTS_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_ENTER_GAME) */ {
 public:
  inline STC_ENTER_GAME() : STC_ENTER_GAME(nullptr) {}
  ~STC_ENTER_GAME() override;
  explicit constexpr STC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_ENTER_GAME(const STC_ENTER_GAME& from);
  STC_ENTER_GAME(STC_ENTER_GAME&& from) noexcept
    : STC_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline STC_ENTER_GAME& operator=(const STC_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_ENTER_GAME& operator=(STC_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const STC_ENTER_GAME*>(
               &_STC_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(STC_ENTER_GAME& a, STC_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_ENTER_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_ENTER_GAME* New() const final {
    return new STC_ENTER_GAME();
  }

  STC_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_ENTER_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_ENTER_GAME& from);
  void MergeFrom(const STC_ENTER_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_ENTER_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_ENTER_GAME";
  }
  protected:
  explicit STC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.STC_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CTS_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CTS_LEAVE_GAME) */ {
 public:
  inline CTS_LEAVE_GAME() : CTS_LEAVE_GAME(nullptr) {}
  ~CTS_LEAVE_GAME() override;
  explicit constexpr CTS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTS_LEAVE_GAME(const CTS_LEAVE_GAME& from);
  CTS_LEAVE_GAME(CTS_LEAVE_GAME&& from) noexcept
    : CTS_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline CTS_LEAVE_GAME& operator=(const CTS_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTS_LEAVE_GAME& operator=(CTS_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTS_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTS_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const CTS_LEAVE_GAME*>(
               &_CTS_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CTS_LEAVE_GAME& a, CTS_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(CTS_LEAVE_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTS_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CTS_LEAVE_GAME* New() const final {
    return new CTS_LEAVE_GAME();
  }

  CTS_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CTS_LEAVE_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CTS_LEAVE_GAME& from);
  void MergeFrom(const CTS_LEAVE_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTS_LEAVE_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CTS_LEAVE_GAME";
  }
  protected:
  explicit CTS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.CTS_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_LEAVE_GAME) */ {
 public:
  inline STC_LEAVE_GAME() : STC_LEAVE_GAME(nullptr) {}
  ~STC_LEAVE_GAME() override;
  explicit constexpr STC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_LEAVE_GAME(const STC_LEAVE_GAME& from);
  STC_LEAVE_GAME(STC_LEAVE_GAME&& from) noexcept
    : STC_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline STC_LEAVE_GAME& operator=(const STC_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_LEAVE_GAME& operator=(STC_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const STC_LEAVE_GAME*>(
               &_STC_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(STC_LEAVE_GAME& a, STC_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_LEAVE_GAME* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_LEAVE_GAME* New() const final {
    return new STC_LEAVE_GAME();
  }

  STC_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_LEAVE_GAME>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_LEAVE_GAME& from);
  void MergeFrom(const STC_LEAVE_GAME& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_LEAVE_GAME* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_LEAVE_GAME";
  }
  protected:
  explicit STC_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.STC_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_SPAWN) */ {
 public:
  inline STC_SPAWN() : STC_SPAWN(nullptr) {}
  ~STC_SPAWN() override;
  explicit constexpr STC_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_SPAWN(const STC_SPAWN& from);
  STC_SPAWN(STC_SPAWN&& from) noexcept
    : STC_SPAWN() {
    *this = ::std::move(from);
  }

  inline STC_SPAWN& operator=(const STC_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_SPAWN& operator=(STC_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_SPAWN* internal_default_instance() {
    return reinterpret_cast<const STC_SPAWN*>(
               &_STC_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(STC_SPAWN& a, STC_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_SPAWN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_SPAWN* New() const final {
    return new STC_SPAWN();
  }

  STC_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_SPAWN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_SPAWN& from);
  void MergeFrom(const STC_SPAWN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_SPAWN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_SPAWN";
  }
  protected:
  explicit STC_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.STC_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_DESPAWN) */ {
 public:
  inline STC_DESPAWN() : STC_DESPAWN(nullptr) {}
  ~STC_DESPAWN() override;
  explicit constexpr STC_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_DESPAWN(const STC_DESPAWN& from);
  STC_DESPAWN(STC_DESPAWN&& from) noexcept
    : STC_DESPAWN() {
    *this = ::std::move(from);
  }

  inline STC_DESPAWN& operator=(const STC_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_DESPAWN& operator=(STC_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const STC_DESPAWN*>(
               &_STC_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(STC_DESPAWN& a, STC_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_DESPAWN* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_DESPAWN* New() const final {
    return new STC_DESPAWN();
  }

  STC_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_DESPAWN>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_DESPAWN& from);
  void MergeFrom(const STC_DESPAWN& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_DESPAWN* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_DESPAWN";
  }
  protected:
  explicit STC_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_object_ids() const;
  void _internal_add_object_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_object_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 object_ids(int index) const;
  void set_object_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_object_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.STC_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > object_ids_;
  mutable std::atomic<int> _object_ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CTS_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CTS_MOVE) */ {
 public:
  inline CTS_MOVE() : CTS_MOVE(nullptr) {}
  ~CTS_MOVE() override;
  explicit constexpr CTS_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTS_MOVE(const CTS_MOVE& from);
  CTS_MOVE(CTS_MOVE&& from) noexcept
    : CTS_MOVE() {
    *this = ::std::move(from);
  }

  inline CTS_MOVE& operator=(const CTS_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTS_MOVE& operator=(CTS_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTS_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTS_MOVE* internal_default_instance() {
    return reinterpret_cast<const CTS_MOVE*>(
               &_CTS_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CTS_MOVE& a, CTS_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(CTS_MOVE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTS_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CTS_MOVE* New() const final {
    return new CTS_MOVE();
  }

  CTS_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CTS_MOVE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CTS_MOVE& from);
  void MergeFrom(const CTS_MOVE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTS_MOVE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CTS_MOVE";
  }
  protected:
  explicit CTS_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.CTS_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_MOVE) */ {
 public:
  inline STC_MOVE() : STC_MOVE(nullptr) {}
  ~STC_MOVE() override;
  explicit constexpr STC_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_MOVE(const STC_MOVE& from);
  STC_MOVE(STC_MOVE&& from) noexcept
    : STC_MOVE() {
    *this = ::std::move(from);
  }

  inline STC_MOVE& operator=(const STC_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_MOVE& operator=(STC_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_MOVE* internal_default_instance() {
    return reinterpret_cast<const STC_MOVE*>(
               &_STC_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(STC_MOVE& a, STC_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_MOVE* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_MOVE* New() const final {
    return new STC_MOVE();
  }

  STC_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_MOVE>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_MOVE& from);
  void MergeFrom(const STC_MOVE& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_MOVE* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_MOVE";
  }
  protected:
  explicit STC_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.STC_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CTS_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CTS_CHAT) */ {
 public:
  inline CTS_CHAT() : CTS_CHAT(nullptr) {}
  ~CTS_CHAT() override;
  explicit constexpr CTS_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTS_CHAT(const CTS_CHAT& from);
  CTS_CHAT(CTS_CHAT&& from) noexcept
    : CTS_CHAT() {
    *this = ::std::move(from);
  }

  inline CTS_CHAT& operator=(const CTS_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTS_CHAT& operator=(CTS_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTS_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTS_CHAT* internal_default_instance() {
    return reinterpret_cast<const CTS_CHAT*>(
               &_CTS_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CTS_CHAT& a, CTS_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(CTS_CHAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTS_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CTS_CHAT* New() const final {
    return new CTS_CHAT();
  }

  CTS_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CTS_CHAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CTS_CHAT& from);
  void MergeFrom(const CTS_CHAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTS_CHAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CTS_CHAT";
  }
  protected:
  explicit CTS_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CTS_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class STC_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STC_CHAT) */ {
 public:
  inline STC_CHAT() : STC_CHAT(nullptr) {}
  ~STC_CHAT() override;
  explicit constexpr STC_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STC_CHAT(const STC_CHAT& from);
  STC_CHAT(STC_CHAT&& from) noexcept
    : STC_CHAT() {
    *this = ::std::move(from);
  }

  inline STC_CHAT& operator=(const STC_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline STC_CHAT& operator=(STC_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STC_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const STC_CHAT* internal_default_instance() {
    return reinterpret_cast<const STC_CHAT*>(
               &_STC_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(STC_CHAT& a, STC_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(STC_CHAT* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STC_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STC_CHAT* New() const final {
    return new STC_CHAT();
  }

  STC_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STC_CHAT>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STC_CHAT& from);
  void MergeFrom(const STC_CHAT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STC_CHAT* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STC_CHAT";
  }
  protected:
  explicit STC_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.STC_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CTS_LOGIN

// -------------------------------------------------------------------

// STC_LOGIN

// bool success = 1;
inline void STC_LOGIN::clear_success() {
  success_ = false;
}
inline bool STC_LOGIN::_internal_success() const {
  return success_;
}
inline bool STC_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.STC_LOGIN.success)
  return _internal_success();
}
inline void STC_LOGIN::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void STC_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.STC_LOGIN.success)
}

// -------------------------------------------------------------------

// CTS_ENTER_GAME

// uint64 playerIndex = 1;
inline void CTS_ENTER_GAME::clear_playerindex() {
  playerindex_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CTS_ENTER_GAME::_internal_playerindex() const {
  return playerindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CTS_ENTER_GAME::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.CTS_ENTER_GAME.playerIndex)
  return _internal_playerindex();
}
inline void CTS_ENTER_GAME::_internal_set_playerindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  playerindex_ = value;
}
inline void CTS_ENTER_GAME::set_playerindex(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.CTS_ENTER_GAME.playerIndex)
}

// -------------------------------------------------------------------

// STC_ENTER_GAME

// bool success = 1;
inline void STC_ENTER_GAME::clear_success() {
  success_ = false;
}
inline bool STC_ENTER_GAME::_internal_success() const {
  return success_;
}
inline bool STC_ENTER_GAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.STC_ENTER_GAME.success)
  return _internal_success();
}
inline void STC_ENTER_GAME::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void STC_ENTER_GAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.STC_ENTER_GAME.success)
}

// -------------------------------------------------------------------

// CTS_LEAVE_GAME

// -------------------------------------------------------------------

// STC_LEAVE_GAME

// -------------------------------------------------------------------

// STC_SPAWN

// -------------------------------------------------------------------

// STC_DESPAWN

// repeated uint64 object_ids = 1;
inline int STC_DESPAWN::_internal_object_ids_size() const {
  return object_ids_.size();
}
inline int STC_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void STC_DESPAWN::clear_object_ids() {
  object_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 STC_DESPAWN::_internal_object_ids(int index) const {
  return object_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 STC_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.STC_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void STC_DESPAWN::set_object_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.STC_DESPAWN.object_ids)
}
inline void STC_DESPAWN::_internal_add_object_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  object_ids_.Add(value);
}
inline void STC_DESPAWN::add_object_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.STC_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
STC_DESPAWN::_internal_object_ids() const {
  return object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
STC_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.STC_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
STC_DESPAWN::_internal_mutable_object_ids() {
  return &object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
STC_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.STC_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// CTS_MOVE

// -------------------------------------------------------------------

// STC_MOVE

// -------------------------------------------------------------------

// CTS_CHAT

// string message = 1;
inline void CTS_CHAT::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& CTS_CHAT::message() const {
  // @@protoc_insertion_point(field_get:Protocol.CTS_CHAT.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTS_CHAT::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CTS_CHAT.message)
}
inline std::string* CTS_CHAT::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Protocol.CTS_CHAT.message)
  return _internal_mutable_message();
}
inline const std::string& CTS_CHAT::_internal_message() const {
  return message_.Get();
}
inline void CTS_CHAT::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CTS_CHAT::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CTS_CHAT::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.CTS_CHAT.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CTS_CHAT::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.CTS_CHAT.message)
}

// -------------------------------------------------------------------

// STC_CHAT

// string message = 1;
inline void STC_CHAT::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& STC_CHAT::message() const {
  // @@protoc_insertion_point(field_get:Protocol.STC_CHAT.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STC_CHAT::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.STC_CHAT.message)
}
inline std::string* STC_CHAT::mutable_message() {
  // @@protoc_insertion_point(field_mutable:Protocol.STC_CHAT.message)
  return _internal_mutable_message();
}
inline const std::string& STC_CHAT::_internal_message() const {
  return message_.Get();
}
inline void STC_CHAT::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* STC_CHAT::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* STC_CHAT::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.STC_CHAT.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void STC_CHAT::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.STC_CHAT.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
